<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-01-31T21:15:20+01:00</updated><id>//</id><title type="html">Tommys Blog</title><subtitle>This is a very sporadic blog where I post things when I feel like it. Most things here will be development oriented. 
</subtitle><entry><title type="html">2 Angular 2 Books</title><link href="/jekyll/update/2017/01/31/Angular2_books.html" rel="alternate" type="text/html" title="2 Angular 2 Books" /><published>2017-01-31T20:17:00+01:00</published><updated>2017-01-31T20:17:00+01:00</updated><id>/jekyll/update/2017/01/31/Angular2_books</id><content type="html" xml:base="/jekyll/update/2017/01/31/Angular2_books.html">&lt;h2 id=&quot;angular-2-by-example-&quot;&gt;Angular 2 By Example (+)&lt;/h2&gt;

&lt;p&gt;This book seem to be from an for me unknown publisher: Packt. It is written by two persons and have at least one proofreader.&lt;/p&gt;

&lt;p&gt;My first impression of this book was good, but that however changed. The book &lt;strong&gt;requires&lt;/strong&gt; you as the reader to have a computer with the book code checked out from Github and have it available as you are reading. There are references to the github code that are not in the book, so you need both to be able to follow. I accepted that, and sat with my laptop in my knee while I read.&lt;/p&gt;

&lt;p&gt;After a while however I came to the conclusion that the structure of the book made it more or less impossible to use as a reference. On top of that I made the huge misstake of bying it from Amazon for the Kindle. At least the Kindle app is not made for such technical books. When you want to go back and forth it is annoyingly difficult with Kindle. I can however not blame the book authors for this.&lt;/p&gt;

&lt;p&gt;I however discovered a lot of errors, spelling mistakes, and pure typos. After a while the book felt like it had been pushed out quickly and not proofread by anyone.&lt;/p&gt;

&lt;p&gt;The structure of the example app the book used as example was also a bit messy in my opinion, and the book/examples did not show the optimal setup for developing. When transpiling (TypeScript –&amp;gt; JavaScript) there were tons of error messages, so many that the scrollback buffer of the terminal got full. In the end the examples did work, but all those error messages bothered me.&lt;/p&gt;

&lt;p&gt;In the end I gave upp and went looking at Manning.com:&lt;/p&gt;

&lt;h2 id=&quot;angular-2-development-with-typescript-&quot;&gt;Angular 2 Development with TypeScript (++++)&lt;/h2&gt;

&lt;p&gt;I apparenlty did forget that all technical books should be purchased from Manning directly, not from Amazon (not sure if Amazon sells Manning books either), since when shopping at Manning you get the books in EPub, Kindle, and PDF formats. And after comparing EPub to PDF, PDF wins large since PDF seems flexible enough to handle both text and symbols, arrows, etc in a page anywhere on the page. For the EPub version of the book, most code examples hade been converted to images that when sized to fit the page got fuzzy. EPub apparently does not handle text and graphics in a flexible way on a page. Manning has also been briliant in handling the PDF format. It was not encrypted, and I was not sent a password by SMS :-). At the bottom of every page they have added “Licensed to Tommy Svensson &lt;a href=&quot;mailto:tommy@natusoft.se&quot;&gt;tommy@natusoft.se&lt;/a&gt;”. That makes sure I don’t share the PDF with anyone :-).&lt;/p&gt;

&lt;p&gt;Anyhow this book I really liked from the start, and I still like it! It has a much better structure of the book, it is usable as a reference, and the example code on github does transpile and run without any errors what so ever! At least so far. I still have a few chapters left to read, but I’m about to jump in and start coding a bit before I continue. The book explains differences in ES5, ES6, and TypeScript and shows example of the same code in all 3 variants early in the book. Otherwise it is only TypeScript that is used in the book.&lt;/p&gt;

&lt;p&gt;This book is easy to read, the example code in the book (and the github code) is very clear and easy to read. They provide arrows to different code lines with text explaining that part of the code. Also in places where code lines are to long to fit on a page line, they clearly show that the next line is a wrap from the previous and is thus part of the same line. The authors really know and understand that they are teaching! This book has 2 authors and 10+ reviewers! There were some small misstakes in the start of the book in some code examples. I started reading the EPub version but then switched to PDF. I suspect that the image-ified code examples in the EPub version were done before the final reviews, and some code were updated without updating the image variants. I’m failing to find the code errors early in the book in the the EPub, in the PDF.&lt;/p&gt;

&lt;p&gt;The book also provide a development setup where the transpiling from TypeScript into JavaScript is automatic so that you can just code in TypeScript, and run. This is very nice for development, but of course the code should be transpiled manually before release version.&lt;/p&gt;

&lt;p&gt;The authors seem very experienced and seems to know what they are talking about. I did not get that impression with the first book.&lt;/p&gt;

&lt;p&gt;I can really recommend this book. &lt;strong&gt;Note&lt;/strong&gt; that if you are like me and wants to make annotations and highlights in the book, then you need a good PDF tool. On Mac for example, Preview is not good enough! This will cost you more than the book did even if you avoid Adobe! This is the only catch with PDF.&lt;/p&gt;</content><summary type="html">Angular 2 By Example (+)</summary></entry><entry><title type="html">A Logical View of writing test code</title><link href="/jekyll/update/2016/12/01/A_Logical_View_of_writing_test_code.html" rel="alternate" type="text/html" title="A Logical View of writing test code" /><published>2016-12-01T11:49:36+01:00</published><updated>2016-12-01T11:49:36+01:00</updated><id>/jekyll/update/2016/12/01/A_Logical_View_of_writing_test_code</id><content type="html" xml:base="/jekyll/update/2016/12/01/A_Logical_View_of_writing_test_code.html">&lt;h1 id=&quot;a-logical-view-of-writing-test-code&quot;&gt;A Logical View of writing test code&lt;/h1&gt;

&lt;p&gt;I continually get, well … shocked, in many cases when I see test code! There are tests for anything and everything, including that java works, that it is possible to add 2 ints and get an int back, etc. Nothing is taken as a given fact, and every single method gets tested no matter what it does. Testing at ridiculous levels does not give you anything, and I would claim do more harm than good.&lt;/p&gt;

&lt;p&gt;I want to provide another view of automatic code testing, thinking logically. I’ll start with 2 questions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;What is the difference between the main code being tested, and the test code ?&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;How do you measure the quality of the test code ?&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do write test code because you don’t know if the main code really does what you intended it to do, that you haven’t made any errors or other mistakes. You also want your test code to protect you in future refactorings. So, how do you accomplish this ? Do you just write your test code, run it, and when it works say “OK, now I believe everything is perfect, now I’m done!” ? If so, what makes you sure ? Personally, I’m an atheist, I don’t take anything on belief. To me if someone says “I now believe this is done!”, I interpret it as “I really don’t know if this is done, but I sincerely hope so”. I also read into this, that people who express themselves like that, really doesn’t know how to become sure. Well, you can never be really sure, but can reach a higher confidence level.&lt;/p&gt;

&lt;p&gt;Why can’t you be sure ? This leads to my first question, “What is the difference between the main code being tested, and the test code ?”. The answer is “&lt;em&gt;Nothing&lt;/em&gt;”! They are both just code. They both have the purpose of providing functionality. So what makes the test code have higher quality than the code tested ? The answer is again “Nothing”! How do you know that you haven’t made errors in the test code ? You don’t!&lt;/p&gt;

&lt;p&gt;“Hey, this guy is pessimistic! Is he really saying tests are worthless ?” No, I’m not! Tests are not worthless, they are very useful and a good thing to have. But you have to accept that there are no plain main code and magic test code.&lt;/p&gt;

&lt;p&gt;This brings on the second question, “&lt;em&gt;How do you measure the quality of the test code ?&lt;/em&gt;”. The only way I have found is: over time. The more you change the main code without touching the test code, and the test code does its job, the more sure you can be about its quality. “But wait, I always have to modify and sometimes redo the test code when I make larger changes and refactorings!”, some people will say. If so, why is that ? Testing at too low levels maybe ? What I wan’t to get out of my tests is to verify the main functionality, and I do that at public API levels. That is, places in the code that are least likely to change, and when they change the changes are usually minor. Thereby I can do a lot of stuff lower down, and if the test still tells me that I haven’t broken anything, then I feel more and more confident over time that, it is true. Anytime I have to modify test code it goes down on the quality scale again.&lt;/p&gt;

&lt;p&gt;“&lt;em&gt;Every single method must have a test!&lt;/em&gt;” Ehh … NO! It does not, for quite obvious reasons. I’ve seen tests that test one line methods printing a log message! I’ve seen tests that does nothing else than verify that Java is capable of doing integer math … A lot of people take test code coverage to mean just that you should have a test for every single method. They don’t seem to consider that when you place the tests higher up, they still run and test the lower code. And if a code coverage tool tells you that there are untested code (code that did not get executed during the test), then you should ask yourself, is that code really used ? Have I covered all functionality variants ? Is my code too complex ? If you put a test on every single method, you will never get that feedback.&lt;/p&gt;</content><summary type="html">A Logical View of writing test code</summary></entry></feed>
